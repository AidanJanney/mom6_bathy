import xesmf as xe
import xarray as xr
from pathlib import Path
import numpy as np
import argparse
from mom6_bathy.aux import get_mesh_dimensions


def grid_from_esmf_mesh(mesh: xr.Dataset | str | Path) -> "Grid":
    """Given an ESMF mesh where the grid metrics are stored in 1D (flattened) arrays,
    compute the dimensions of the 2D grid and return a 2D horizontal grid dataset
    containing the longitude, latitude, and mask of the grid points which are all that
    is needed to create a regridder.

    Parameters
    ----------
    mesh : xr.Dataset or str or Path
        The ESMF mesh dataset or the path to the mesh file.

    Returns
    -------
    ds : xr.Dataset
        A 2D horizontal grid dataset containing the longitude, latitude, and mask of the grid points.
    """

    if not isinstance(mesh, xr.Dataset):
        assert isinstance(mesh, (Path, str)) and Path(mesh).exists(), "mesh must be a path to an existing file"
        mesh = xr.open_dataset(mesh)

    nx, ny = get_mesh_dimensions(mesh)

    lon = mesh['centerCoords'][:, 0].values.reshape((ny, nx))
    lat = mesh['centerCoords'][:, 1].values.reshape((ny, nx))
    mask = mesh['elementMask'].values.reshape((ny, nx))

    ds = xr.Dataset(
        {
            'lon': (('nlat', 'nlon'), lon),
            'lat': (('nlat', 'nlon'), lat),
            'mask': (('nlat', 'nlon'), mask),
        },
        coords={'nlat': np.arange(ny), 'nlon': np.arange(nx)}
    )

    return ds

def extract_coastline_mask(horiz_grid):
    """Given a 2D horizontal grid dataset, extract the coastline mask.

    Parameters
    ----------
    horiz_grid : xr.Dataset
        A 2D horizontal grid dataset containing the longitude, latitude, and mask of the grid points.
        This dataset may be obtained from the grid_from_esmf_mesh function by passing an ESMF mesh.

    Returns
    -------
    da_coastline_mask : xr.DataArray
        A 2D DataArray containing the coastline mask.
    """

    mask = horiz_grid['mask']

    # Apply padding to facilitate the diff operation
    mask_padded = np.pad(mask, pad_width=1, mode='wrap')

    coastline_mask = np.where(
        (
            (np.diff(mask_padded[:-1, 1:-1], axis=0) == 1) | (np.diff(mask_padded[1:, 1:-1], axis=0) == -1) |
            (np.diff(mask_padded[1:-1, :-1], axis=1) == 1) | (np.diff(mask_padded[1:-1, 1:], axis=1) == -1)
        ),
        1, 0
    )

    da_coastline_mask = mask.copy(data=coastline_mask)
    return da_coastline_mask


def sum_weights(regridder, stride=1):
    nx_in, ny_in = regridder.grid_in.get_shape()
    nx_out, ny_out = regridder.grid_out.get_shape()

    s = sum([(regridder.weights[:,i].data.reshape((ny_out,nx_out)).todense()) for i in range(0,ny_in*nx_in,stride)])
    da = xr.DataArray(s, dims=['nlat', 'nlon'], coords={'nlat': range(ny_out), 'nlon': range(nx_out)})
    return da


def _construct_vertex_coords(mesh):
    """Construct the vertex coordinates for a given mesh that's participating in a
    mapping generation. The mesh could be src or dst mesh.

    Parameters
    ----------
    mesh : xr.Dataset
        The ESMF mesh dataset.
    Returns
    -------
    xv_data : np.ndarray
        The vertex coordinates in the x-direction.
    yv_data : np.ndarray
        The vertex coordinates in the y-direction.
    """

    xv_data = np.full((len(mesh.centerCoords.data), 4), np.nan)
    yv_data = np.full((len(mesh.centerCoords.data), 4), np.nan)

    element_conn = mesh.elementConn.data - 1  # one-based to zero-based indexing
    node_coords = mesh.nodeCoords.data

    for e, nodes in enumerate(element_conn):
        if np.isnan(nodes[3]):
            valid_nodes = nodes[:3][~np.isnan(nodes[:3])].astype(int)
            xv_data[e, :3] = node_coords[valid_nodes, 0]
            xv_data[e, 3] = xv_data[e, 2]
            yv_data[e, :3] = node_coords[valid_nodes, 1]
            yv_data[e, 3] = yv_data[e, 2]
        else:
            valid_nodes = nodes.astype(int)
            xv_data[e, :] = node_coords[valid_nodes, 0]
            yv_data[e, :] = node_coords[valid_nodes, 1]
    
    return xv_data, yv_data

def generate_ESMF_map(src_mesh, dst_mesh, weights, filename):
    """Based on a given source mesh, destination mesh, and weights, generate an ESMF map file.
    
    Parameters
    ----------
    src_mesh : str, xr.Dataset
        ESMF mesh object or path to the source ESMF mesh file.
    dst_mesh : str, xr.Dataset
        ESMF mesh object or path to the destination ESMF mesh file.
    weights : xr.DataArray
        Weights to be used for the regridding. (To be generated by xESMF)
    filename : str
        Path to the output ESMF map file.
    regrid_method : str, optional
        Regridding method, by default 'bilinear'.

    Returns
    -------
    None
    """

    if isinstance(src_mesh, str):
        src_mesh = xr.open_dataset(src_mesh)
    if isinstance(dst_mesh, str):
        dst_mesh = xr.open_dataset(dst_mesh)

    # From 1D ESMF mesh to 2D grid
    src_grid = grid_from_esmf_mesh(src_mesh)
    dst_grid = grid_from_esmf_mesh(dst_mesh)

    # 1/3: Source Domain Fields
    # -------------------

    xc_a = xr.DataArray(
        src_mesh.centerCoords.data[:, 0],
        dims=['n_a'],
        attrs={
            'long_name': 'longitude of grid cell center (input)',
            'units': 'degrees east'
        }
    )

    yc_a = xr.DataArray(
        src_mesh.centerCoords.data[:, 1],
        dims=['n_a'],
        attrs={
            'long_name': 'latitude of grid cell center (input)',
            'units': 'degrees north'
        }
    )

    xv_a_data, yv_a_data = _construct_vertex_coords(src_mesh)

    xv_a = xr.DataArray(
        xv_a_data,
        dims=['n_a', 'nv_a'],
        attrs={
            'long_name': 'longitude of grid cell verticies (input)',
            'units': 'degrees east'
        }
    )

    yv_a = xr.DataArray(
        yv_a_data,
        dims=['n_a', 'nv_a'],
        attrs={
            'long_name': 'latitude of grid cell verticies (input)',
            'units': 'degrees north'
        }
    )

    mask_a = xr.DataArray(
        src_mesh.elementMask.data,
        dims=['n_a'],
        attrs={
            'long_name': 'domain mask (input)',
        }
    )

    area_a = xr.DataArray(
        src_mesh.elementArea.data,
        dims=['n_a'],
        attrs={
            'long_name': 'area of cell (input)',
            #'units': 'm^2'
        }
    )

    frac_a = xr.DataArray(
        src_mesh.elementMask.data.astype(np.float64),
        dims=['n_a'],
        attrs={
            'long_name': 'fraction of domain intersection (input)',
            #'units': ''
        }
    )

    src_grid_dims = xr.DataArray(
        np.array(src_grid.mask.shape[::-1]).astype(np.int32),
        dims=['src_grid_rank'],
        #attrs={
        #    'long_name': 'dimensions of the source grid',
        #}
    )

    nj_a = xr.DataArray(
        [i+1 for i in range(src_grid.mask.shape[0])],
        dims=['nj_a'],
    )

    ni_a = xr.DataArray(
        [i+1 for i in range(src_grid.mask.shape[1])],
        dims=['ni_a'],
    )

    # 2/3: Destination Domain Fields
    # -------------------

    xc_b = xr.DataArray(
        dst_mesh.centerCoords.data[:, 0],
        dims=['n_b'],
        attrs={
            'long_name': 'longitude of grid cell center (output)',
            'units': 'degrees east'
        }
    )

    yc_b = xr.DataArray(
        dst_mesh.centerCoords.data[:, 1],
        dims=['n_b'],
        attrs={
            'long_name': 'latitude of grid cell center (output)',
            'units': 'degrees north'
        }
    )

    xv_b_data, yv_b_data = _construct_vertex_coords(dst_mesh)

    xv_b = xr.DataArray(
        xv_b_data,
        dims=['n_b', 'nv_b'],
        attrs={
            'long_name': 'longitude of grid cell verticies (output)',
            'units': 'degrees east'
        }
    )

    yv_b = xr.DataArray(
        yv_b_data,
        dims=['n_b', 'nv_b'],
        attrs={
            'long_name': 'latitude of grid cell verticies (output)',
            'units': 'degrees north'
        }
    )

    mask_b = xr.DataArray(
        dst_mesh.elementMask.data,
        dims=['n_b'],
        attrs={
            'long_name': 'domain mask (output)',
        }
    )

    area_b = xr.DataArray(
        dst_mesh.elementArea.data,
        dims=['n_b'],
        attrs={
            'long_name': 'area of cell (output)',
            #'units': 'm^2'
        }
    )

    frac_b = xr.DataArray(
        dst_mesh.elementMask.data.astype(np.float64),
        dims=['n_b'],
        attrs={
            'long_name': 'fraction of domain intersection (output)',
            #'units': ''
        }
    )

    dst_grid_dims = xr.DataArray(
        np.array(dst_grid.mask.shape[::-1]).astype(np.int32),
        dims=['dst_grid_rank'],
        #dst_grid_dimsattrs={
        #    'long_name': 'dimensions of the destination grid',
        #}
    )

    nj_b = xr.DataArray(
        [i+1 for i in range(dst_grid.mask.shape[0])],
        dims=['nj_b'],
    )

    ni_b = xr.DataArray(
        [i+1 for i in range(dst_grid.mask.shape[1])],
        dims=['ni_b'],
    )

    # 3/3: Weights
    # -------------------

    w = weights.data

    S = xr.DataArray(
        w.data,
        dims=['n_s'],
        attrs={
            'long_name': 'sparse matrix for mapping S:a->b',
        }
    )

    col = xr.DataArray(
        w.coords[1, :] + 1,
        dims=['n_s'],
        attrs={
            'long_name': 'column corresponding to matrix elements',
        }
    )

    row = xr.DataArray(
        w.coords[0, :] + 1,
        dims=['n_s'],
        attrs={
            'long_name': 'row corresponding to matrix elements',
        }
    )

    # Drop NaN values from S, col, and row
    non_nan_indices = np.where(~np.isnan(S))[0]
    S_new = S[non_nan_indices]
    row_new = row[non_nan_indices]
    col_new = col[non_nan_indices]

    # Create the dataset and write to a netCDF file
    # ------------------------------------------------

    ds = xr.Dataset(
        {
            'xc_a': xc_a,
            'yc_a': yc_a,
            'xv_a': xv_a,
            'yv_a': yv_a,
            'mask_a': mask_a,
            'area_a': area_a,
            'frac_a': frac_a,
            'src_grid_dims': src_grid_dims,
            'nj_a': nj_a,
            'ni_a': ni_a,
            'xc_b': xc_b,
            'yc_b': yc_b,
            'xv_b': xv_b,
            'yv_b': yv_b,
            'mask_b': mask_b,
            'area_b': area_b,
            'frac_b': frac_b,
            'dst_grid_dims': dst_grid_dims,
            'nj_b': nj_b,
            'ni_b': ni_b,
            'S': S_new,
            'col': col_new,
            'row': row_new,
        }
    )

    ds.attrs['title'] = 'mom6_bathy mapping generation'
    #ds.attrs['normalization'] = 'conservative' # todo
    #ds.attrs['map_method'] = 'nearest neighbor smoothing'
    ds.attrs['history'] = 'generated by mom6_bathy'
    ds.attrs['conventions'] = 'NCAR-CCSM'
    #ds.attrs['domain_a'] = '/glade/p/cesmdata/cseg/inputdata/lnd/dlnd7/RX1/runoff.daitren.annual.090225.nc'
    #ds.attrs['domain_b'] = '/glade/work/gmarques/cesm/tx2_3/mesh/tx2_3_SCRIP_230415.nc'

    ds.to_netcdf(
        filename,
        format='NETCDF3_64BIT',
        encoding={var: {'_FillValue': None} for var in ds.data_vars}
    )
    


def generate_ESMF_map_esmpy(src_mesh, dst_mesh, S, row, col, filename):
    """Based on a given source mesh, destination mesh, and weights, generate an ESMF map file.
    
    Parameters
    ----------
    src_mesh : str, xr.Dataset
        ESMF mesh object or path to the source ESMF mesh file.
    dst_mesh : str, xr.Dataset
        ESMF mesh object or path to the destination ESMF mesh file.
    filename : str
        Path to the output ESMF map file.
    regrid_method : str, optional
        Regridding method, by default 'bilinear'.

    Returns
    -------
    None
    """

    if isinstance(src_mesh, str):
        src_mesh = xr.open_dataset(src_mesh)
    if isinstance(dst_mesh, str):
        dst_mesh = xr.open_dataset(dst_mesh)

    # From 1D ESMF mesh to 2D grid
    src_grid = grid_from_esmf_mesh(src_mesh)
    dst_grid = grid_from_esmf_mesh(dst_mesh)

    # 1/3: Source Domain Fields
    # -------------------

    xc_a = xr.DataArray(
        src_mesh.centerCoords.data[:, 0],
        dims=['n_a'],
        attrs={
            'long_name': 'longitude of grid cell center (input)',
            'units': 'degrees east'
        }
    )

    yc_a = xr.DataArray(
        src_mesh.centerCoords.data[:, 1],
        dims=['n_a'],
        attrs={
            'long_name': 'latitude of grid cell center (input)',
            'units': 'degrees north'
        }
    )

    xv_a_data, yv_a_data = _construct_vertex_coords(src_mesh)

    xv_a = xr.DataArray(
        xv_a_data,
        dims=['n_a', 'nv_a'],
        attrs={
            'long_name': 'longitude of grid cell verticies (input)',
            'units': 'degrees east'
        }
    )

    yv_a = xr.DataArray(
        yv_a_data,
        dims=['n_a', 'nv_a'],
        attrs={
            'long_name': 'latitude of grid cell verticies (input)',
            'units': 'degrees north'
        }
    )

    mask_a = xr.DataArray(
        src_mesh.elementMask.data,
        dims=['n_a'],
        attrs={
            'long_name': 'domain mask (input)',
        }
    )

    area_a = xr.DataArray(
        src_mesh.elementArea.data,
        dims=['n_a'],
        attrs={
            'long_name': 'area of cell (input)',
            #'units': 'm^2'
        }
    )

    frac_a = xr.DataArray(
        src_mesh.elementMask.data.astype(np.float64),
        dims=['n_a'],
        attrs={
            'long_name': 'fraction of domain intersection (input)',
            #'units': ''
        }
    )

    src_grid_dims = xr.DataArray(
        np.array(src_grid.mask.shape[::-1]).astype(np.int32),
        dims=['src_grid_rank'],
        #attrs={
        #    'long_name': 'dimensions of the source grid',
        #}
    )

    nj_a = xr.DataArray(
        [i+1 for i in range(src_grid.mask.shape[0])],
        dims=['nj_a'],
    )

    ni_a = xr.DataArray(
        [i+1 for i in range(src_grid.mask.shape[1])],
        dims=['ni_a'],
    )

    # 2/3: Destination Domain Fields
    # -------------------

    xc_b = xr.DataArray(
        dst_mesh.centerCoords.data[:, 0],
        dims=['n_b'],
        attrs={
            'long_name': 'longitude of grid cell center (output)',
            'units': 'degrees east'
        }
    )

    yc_b = xr.DataArray(
        dst_mesh.centerCoords.data[:, 1],
        dims=['n_b'],
        attrs={
            'long_name': 'latitude of grid cell center (output)',
            'units': 'degrees north'
        }
    )

    xv_b_data, yv_b_data = _construct_vertex_coords(dst_mesh)

    xv_b = xr.DataArray(
        xv_b_data,
        dims=['n_b', 'nv_b'],
        attrs={
            'long_name': 'longitude of grid cell verticies (output)',
            'units': 'degrees east'
        }
    )

    yv_b = xr.DataArray(
        yv_b_data,
        dims=['n_b', 'nv_b'],
        attrs={
            'long_name': 'latitude of grid cell verticies (output)',
            'units': 'degrees north'
        }
    )

    mask_b = xr.DataArray(
        dst_mesh.elementMask.data,
        dims=['n_b'],
        attrs={
            'long_name': 'domain mask (output)',
        }
    )

    area_b = xr.DataArray(
        dst_mesh.elementArea.data,
        dims=['n_b'],
        attrs={
            'long_name': 'area of cell (output)',
            #'units': 'm^2'
        }
    )

    frac_b = xr.DataArray(
        dst_mesh.elementMask.data.astype(np.float64),
        dims=['n_b'],
        attrs={
            'long_name': 'fraction of domain intersection (output)',
            #'units': ''
        }
    )

    dst_grid_dims = xr.DataArray(
        np.array(dst_grid.mask.shape[::-1]).astype(np.int32),
        dims=['dst_grid_rank'],
        #dst_grid_dimsattrs={
        #    'long_name': 'dimensions of the destination grid',
        #}
    )

    nj_b = xr.DataArray(
        [i+1 for i in range(dst_grid.mask.shape[0])],
        dims=['nj_b'],
    )

    ni_b = xr.DataArray(
        [i+1 for i in range(dst_grid.mask.shape[1])],
        dims=['ni_b'],
    )

    # 3/3: Weights
    # -------------------

    da_S = xr.DataArray(
        S,
        dims=['n_s'],
        attrs={
            'long_name': 'sparse matrix for mapping S:a->b',
        }
    )

    da_col = xr.DataArray(
        col,
        dims=['n_s'],
        attrs={
            'long_name': 'column corresponding to matrix elements',
        }
    )

    da_row = xr.DataArray(
        row,
        dims=['n_s'],
        attrs={
            'long_name': 'row corresponding to matrix elements',
        }
    )

    # Create the dataset and write to a netCDF file
    # ------------------------------------------------

    ds = xr.Dataset(
        {
            'xc_a': xc_a,
            'yc_a': yc_a,
            'xv_a': xv_a,
            'yv_a': yv_a,
            'mask_a': mask_a,
            'area_a': area_a,
            'frac_a': frac_a,
            'src_grid_dims': src_grid_dims,
            'nj_a': nj_a,
            'ni_a': ni_a,
            'xc_b': xc_b,
            'yc_b': yc_b,
            'xv_b': xv_b,
            'yv_b': yv_b,
            'mask_b': mask_b,
            'area_b': area_b,
            'frac_b': frac_b,
            'dst_grid_dims': dst_grid_dims,
            'nj_b': nj_b,
            'ni_b': ni_b,
            'S': da_S,
            'col': da_col,
            'row': da_row,
        }
    )

    ds.attrs['title'] = 'mom6_bathy mapping generation'
    #ds.attrs['normalization'] = 'conservative' # todo
    #ds.attrs['map_method'] = 'nearest neighbor smoothing'
    ds.attrs['history'] = 'generated by mom6_bathy'
    ds.attrs['conventions'] = 'NCAR-CCSM'
    #ds.attrs['domain_a'] = '/glade/p/cesmdata/cseg/inputdata/lnd/dlnd7/RX1/runoff.daitren.annual.090225.nc'
    #ds.attrs['domain_b'] = '/glade/work/gmarques/cesm/tx2_3/mesh/tx2_3_SCRIP_230415.nc'

    ds.to_netcdf(
        filename,
        format='NETCDF3_64BIT',
        encoding={var: {'_FillValue': None} for var in ds.data_vars}
    )
    




def main(args):

    mesh = args.mesh

    get_grid_size(mesh)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Map 1D ESMF mesh to a 2D horizontal grid")
    parser.add_argument("mesh", type=str, help="Path to the 1D ESMF mesh")
    args = parser.parse_args()
    main(args)